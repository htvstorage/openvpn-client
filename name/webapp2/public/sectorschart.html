<!DOCTYPE html>
<html>

<head>
    <title>MultiSymbol Chart</title>
    <script src="https://code.jquery.com/jquery-3.7.0.js"></script>
    <script src="https://cdn.datatables.net/1.13.7/js/jquery.dataTables.min.js"></script>
    <script src="https://cdn.datatables.net/buttons/2.4.2/js/dataTables.buttons.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.1.53/pdfmake.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.1.53/vfs_fonts.js"></script>
    <script src="https://cdn.datatables.net/buttons/2.4.2/js/buttons.html5.min.js"></script>
    <script src="https://cdn.datatables.net/buttons/2.4.2/js/buttons.print.min.js"></script>
    <!-- <script src="https://cdn.datatables.net/scroller/2.3.0/js/dataTables.scroller.min.js"></script> -->
    <script src="https://cdn.datatables.net/keytable/2.11.0/js/dataTables.keyTable.min.js"></script>
    <script src="https://cdn.datatables.net/buttons/2.4.2/js/buttons.colVis.min.js"></script>
    <script src="https://cdn.datatables.net/fixedcolumns/4.3.0/js/dataTables.fixedColumns.min.js"></script>
    <script src="https://cdn.datatables.net/fixedheader/3.4.0/js/dataTables.fixedHeader.min.js"></script>


    <link rel="stylesheet" type="text/css"
        href="https://cdn.datatables.net/fixedheader/3.4.0/css/fixedHeader.dataTables.min.css">
    <link rel="stylesheet" type="text/css"
        href="https://cdn.datatables.net/fixedcolumns/4.3.0/css/fixedColumns.dataTables.min.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/1.13.7/css/jquery.dataTables.min.css">
    <link rel="stylesheet" type="text/css"
        href="https://cdn.datatables.net/scroller/2.3.0/css/scroller.dataTables.min.css">
    <link rel="stylesheet" type="text/css"
        href="https://cdn.datatables.net/keytable/2.11.0/css/keyTable.dataTables.min.css">
    <link rel="stylesheet" type="text/css"
        href="https://cdn.datatables.net/buttons/2.4.2/css/buttons.dataTables.min.css">


    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"
        integrity="sha384-c79GN5VsunZvi+Q/WObgk2in0CbZsHnjEqvFxC5DxHn9lTfNce2WW6h2pH6u/kF+"
        crossorigin="anonymous"></script>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/numeral.js/2.0.6/numeral.min.js"></script>

    <link rel="stylesheet" type="text/css" href="tooltipster.bundle.min.css">
    <script type="text/javascript" charset="utf8" src="tooltipster.bundle.min.js"></script>

    <style>
        div.dataTables_wrapper div.dataTables_info {
            padding-top: 0px;
        }

        div.dataTables_wrapper div.dataTables_info {
            font-size: 6px;
            /* Set font size for information text (e.g., "Showing 1 to 10 of 100 entries") */
        }

        table {
            border-collapse: collapse;
            width: 100%;
        }

        table,
        th,
        td {
            border: 1px solid #ccc;
        }

        th,
        td {
            padding: 8px;
            text-align: left;
        }

        th {
            background-color: #f2f2f2;
        }
    </style>
    <style>
        /* CSS for limiting the number of rows and adding a vertical scroll */
        #timelineContainer {
            max-height: 600px;
            /* Set the maximum height for the table */
            overflow-y: auto;
            /* Enable vertical scrolling */
        }
    </style>
    <style>
        /* CSS for enabling both horizontal and vertical scrolling for the entire page */
        body,
        html {
            overflow: scroll;
            /* Enable both horizontal and vertical scrolling for the entire page */
        }
    </style>
    <style>
        /* #chartcontainer {
            text-align: center;
        }

        #vnindex,#busd {
            display: inline;
        } */
        #chartcontainer {
            display: flex;
            justify-content: center;
        }

        #combineDiv {
            display: flex;
            /* flex-wrap: wrap; */
            /* Cho phép các ô chuyển hàng khi không đủ không gian */
            /* justify-content: center; */
        }

        .hidden-element {
            display: none;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(3, 700px);
            /* 3 cột trong mỗi hàng */
            grid-gap: 10px;
            /* Khoảng cách giữa các ô */
            /* grid-auto-rows: 300px; */
        }

        .grid-item {
            /* Định dạng cho mỗi ô trong grid */
            border: 1px solid #ddd;
            padding: 10px;
            width: 700px;
            /* Chiều rộng của mỗi ô */
            height: 700px;
            /* Chiều cao của mỗi ô */
        }

        .flex-container {
            display: flex;
            flex-wrap: wrap;
            /* Cho phép các ô chuyển hàng khi không đủ không gian */
            justify-content: center;
        }

        .flex-item3 {
            flex: 0 0 calc(33.33% - 20px);
            /* 33.33% chiều rộng mỗi ô, trừ đi khoảng cách giữa các ô */
            box-sizing: border-box;
            /* Đảm bảo padding và border không làm tăng kích thước thực tế của ô */
            margin: 10px;
            /* Khoảng cách giữa các ô */
        }

        .flex-item2 {
            flex: 0 0 calc(50% - 20px);
            /* 33.33% chiều rộng mỗi ô, trừ đi khoảng cách giữa các ô */
            box-sizing: border-box;
            /* Đảm bảo padding và border không làm tăng kích thước thực tế của ô */
            margin: 10px;
            /* Khoảng cách giữa các ô */
        }

        .flex-item1 {
            flex: 0 0 calc(100% - 20px);
            /* 33.33% chiều rộng mỗi ô, trừ đi khoảng cách giữa các ô */
            box-sizing: border-box;
            /* Đảm bảo padding và border không làm tăng kích thước thực tế của ô */
            margin: 10px;
            /* Khoảng cách giữa các ô */
        }

        .flex-itemOne {
            flex: 0 0 calc(80% - 20px);
            /* 33.33% chiều rộng mỗi ô, trừ đi khoảng cách giữa các ô */
            box-sizing: border-box;
            /* Đảm bảo padding và border không làm tăng kích thước thực tế của ô */
            margin: 10px;
            /* Khoảng cách giữa các ô */
        }

        .custom-link {
            text-decoration: none !important;
        }

        /* .tooltip {
            position: absolute;
            z-index: 1;
            background-color: #f9f9f9;
            border: 1px solid #ccc;
            padding: 5px;
            border-radius: 5px;
            display: none;
        } */
    </style>
</head>

<body>
    <br />
    <br />
    <br />
    <div id="combineDiv" class="flex-container">
    </div>
    <!-- <div class="tooltip" id="tooltipContainer"></div> -->
    <table id="myTable" class="display">
        <thead>
            <tr>
                <th>Sector</th>
                <th>Thời gian</th>
                <th>Mã Trần</th>
                <th>Mã Tăng</th>
                <th>Mã Đứng Giá</th>
                <th>Mã Giảm</th>
                <th>Mã Sàn</th>
            </tr>
        </thead>
        <!-- <tfoot id="footTable">
            <tr>
                <th>Thống kê</th>
                <th></th>
                <th></th>
            </tr>
        </tfoot> -->
        <tbody>
            <!-- Dữ liệu sẽ được thêm ở đây -->
        </tbody>

    </table>


    <script>
        let vf = (v) => {
            if (v) return v;
            return 0
        }
        const url = new URL(window.location.href);
        const queryParams = url.searchParams;
        var interval = queryParams.get('interval');
        if (!interval) interval = 60
        var sortby = queryParams.get('sortby');
        if (!sortby) {
            sortby = 'pct'
        }


        var percent = queryParams.get('percent');
        let combineDivContainer = document.getElementById('combineDiv')
        var width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
        let flex = "flex-item2"
        if (width < 1024) {
            flex = "flex-item1"
        } else if (width > 1024 && width <= 1920) {
            flex = "flex-item2"
        } else {
            flex = "flex-item3"
        }
        flex = "flex-item2"
        if (combineDivContainer) {
            let innerHTML = '';
            innerHTML += '<div class="' + flex + '"><canvas id="' + 'stackedsectors' + 'Chart" style="width: 100%; margin: 0 auto;"></canvas></div>'
            innerHTML += '<div class="' + flex + '"><canvas id="' + 'stackedsectorsVal' + 'Chart" style="width: 100%; margin: 0 auto;"></canvas></div>'
            combineDivContainer.innerHTML = innerHTML;
        }



        const zoomOptions = {
            // pan: {
            //     enabled: true,
            //     mode: 'xy',
            //     modifierKey: 'ctrl',
            // },
            pan: {
                enabled: true,
                onPanStart({ chart, point }) {
                    const area = chart.chartArea;
                    const w25 = area.width * 0.25;
                    const h25 = area.height * 0.25;
                    if (point.x < area.left + w25 || point.x > area.right - w25
                        || point.y < area.top + h25 || point.y > area.bottom - h25) {
                        return false; // abort
                    }
                },
                mode: 'xy',
            },
            zoom: {
                mode: 'xy',
                drag: {
                    enabled: true,
                    borderColor: 'rgb(54, 162, 235)',
                    borderWidth: 1,
                    backgroundColor: 'rgba(54, 162, 235, 0.3)'
                }
            }
        };

        function createChart(symbol) {
            //combineChart
            const ctxCombineChart = document.getElementById(symbol + 'Chart').getContext('2d');
            var lineTension = 0.2
            const combineData = {
                labels: ['A', 'B', 'C'],
                datasets: [
                    {
                        label: 'Mã trần',
                        lineTension: lineTension,
                        xAxisID: 'xlabels',
                        yAxisID: 'y-axis-vnindex',
                        data: [1, 2],//Array(2).fill().map(() => Math.floor(Math.random() * 100)),
                        borderColor: 'Magenta',
                        backgroundColor: 'Magenta',
                        pointRadius: 2, // Kích thước đánh dấu
                        pointHoverRadius: 6, // Kích thước đánh dấu khi di chuột qua   
                        borderWidth: 2, // Kích thước của đường                        
                        stack: 'Stack 0',

                    },
                    {
                        label: 'Mã tăng',
                        lineTension: lineTension,
                        yAxisID: 'y-axis-vnindex',
                        borderColor: 'green',
                        backgroundColor: 'green', // Red
                        data: [3, 4],
                        fill: false,
                        // hidden: true, // Ẩn đường này mặc định
                        pointRadius: 2, // Kích thước đánh dấu
                        pointHoverRadius: 6, // Kích thước đánh dấu khi di chuột qua   
                        borderWidth: 2, // Kích thước của đường  
                        stack: 'Stack 0',
                    },
                    {
                        label: 'Mã đứng giá',
                        lineTension: lineTension,
                        yAxisID: 'y-axis-vnindex',
                        borderColor: 'gold',
                        backgroundColor: 'gold', // Blue
                        data: [5, 6],
                        fill: false,
                        pointRadius: 2, // Kích thước đánh dấu
                        pointHoverRadius: 6, // Kích thước đánh dấu khi di chuột qua   
                        borderWidth: 2, // Kích thước của đường                        
                        stack: 'Stack 0',
                    },
                    {
                        label: 'Mã giảm',
                        lineTension: lineTension,
                        yAxisID: 'y-axis-vnindex',
                        borderColor: 'red',
                        backgroundColor: 'red', // Blue
                        data: [7, 8],
                        fill: false,
                        pointRadius: 2, // Kích thước đánh dấu
                        pointHoverRadius: 6, // Kích thước đánh dấu khi di chuột qua   
                        borderWidth: 2, // Kích thước của đường                    
                        stack: 'Stack 0',
                    },
                    {
                        label: 'Mã sàn',
                        lineTension: lineTension,
                        yAxisID: 'y-axis-vnindex',
                        borderColor: 'cyan',
                        backgroundColor: 'cyan', // Blue
                        data: [9, 10],
                        fill: false,
                        pointRadius: 2, // Kích thước đánh dấu
                        pointHoverRadius: 6, // Kích thước đánh dấu khi di chuột qua   
                        borderWidth: 2, // Kích thước của đường                        
                        stack: 'Stack 0',
                    }
                ],
            };
            const combineConfig = {
                type: 'bar', // Đây là loại biểu đồ đường (line chart)
                data: combineData,
                options: {
                    indexAxis: 'y',
                    legend: {
                        position: 'right',
                    },
                    scales: {
                        // x: {
                        //     position: 'right',
                        //     stacked: true,
                        // },
                        // y: {
                        //     stacked: true
                        // },
                        'xlabels': {
                            // stacked: true,
                            position: 'top',
                            title: {
                                display: true,
                                text: symbol,
                                font: {
                                    size: 24,          // Kích thước phông chữ
                                    weight: 'bold',  // In đậm                                
                                }
                            },
                        },
                        'y-axis-vnindex': {
                            // stacked: true,
                            // position: 'right',
                            title: {
                                display: true,
                                text: symbol,
                                font: {
                                    size: 24,          // Kích thước phông chữ
                                    weight: 'bold',  // In đậm                                
                                }
                            },
                        },

                    },
                    plugins: {
                        zoom: zoomOptions,
                    }
                },

            };
            var combineChart = new Chart(ctxCombineChart, combineConfig);
            return combineChart;
        }


        var combineChart = createChart('stackedsectors');
        var combineChartVal = createChart('stackedsectorsVal');

        let fields = ["sector", "time"
            , "tran", "tang", "thamchieu", "giam", "san",
        ]

        $.fn.dataTable.ext.errMode = 'none';

        $('#myTable').DataTable(
            {
                fixedHeader: {
                    // header: true,
                    // footer: true
                },
                fixedColumns: {
                    left: 1,
                    right: 1
                },
                columnDefs: [

                    { targets: 1, "width": "5%" },
                    {
                        targets: [2, 3, 4, 5, 6],
                        render: function (data, type, row, meta) {
                            let a = Object.values(data).sort((a, b) => {
                                switch (sortby) {
                                    case 'tong':
                                        return (vf(b.bu_val) + vf(b.sd_val) + vf(b.unknown_val)) - (vf(a.bu_val) + vf(a.sd_val) + vf(a.unknown_val))
                                        break
                                    default:
                                        return b[sortby] - a[sortby]
                                }

                            })
                            count = 0;
                            var dataout = ''
                            if (type === 'display') {
                                a.forEach(s => {
                                    count++;
                                    var color = 'blue'

                                    color = count % 2 === 0 ? 'blue' : 'green';
                                    if (count % 5 === 0) {
                                        // dataout += '<br/>'
                                    }

                                    // console.log(JSON.stringify(s))
                                    dataout += '<a href="timeline?symbols=' + encodeURIComponent(s.symbol) + '"  target="_blank" class="custom-link"> <span style="color: ' + color + ';" class="tooltip"    data-tooltip=\'' + JSON.stringify(s) + '\'>(' + s.symbol + ':' + s.pct + ')</span> </a>';
                                    // dataout += '<a href="timeline?symbols=' + encodeURIComponent(s.symbol) + '"  target="_blank" class="custom-link"> <span style="color: ' + color + ';" class="tooltip"    data-tooltipster=\'' + JSON.stringify(s) + '\'>(' + s.symbol + ':' + s.pct + ')</span> </a>';
                                    // dataout += '<a href="timeline?symbols=' + encodeURIComponent(s.symbol) + '"  target="_blank" class="custom-link"> <span style="color: ' + color + ';" class="tooltip"   data-tooltip="' + s.bu_val + '<br/>' + s.sd_val + '">(' + s.symbol + ':' + s.pct + ')</span> </a>';
                                    // dataout += '<a href="timeline?symbols=' + encodeURIComponent(s.symbol) + '"  target="_blank" class="custom-link"> <span style="color: ' + color + ';" data-html="true" class="tooltip"  title="' + s.bu_val + '<br/>' + s.sd_val + '">(' + s.symbol + ':' + s.pct + ')</span> </a>';
                                })

                            }
                            return dataout;
                        }
                    },
                ],
                columns: [
                    ...fields.map(e => { return { data: e, orderable: true } })
                ],
                rowCallback: function (row, data, index) {
                    // if ((data['pct'] < 0)) {
                    //     // $(row).css('background-color', 'red');                
                    //     $('td:eq(5)', row).css('background-color', 'red');
                    // }
                    // else if ((data['pct'] > 0)) {
                    //     // $(row).css('background-color', 'green');
                    //     $('td:eq(5)', row).css('background-color', 'limegreen');
                    // } else {
                    //     // $(row).css('background-color', 'yellow');
                    //     $('td:eq(5)', row).css('background-color', 'yellow');
                    // }
                },
                order: [[2, 'desc']],
                processing: true,
                ordering: true,
                scroller: true,
                // scrollY: 200,
                searching: true,
                // serverSide: true,
                lengthMenu: [30, 50, 100, 200, 500, 2000],
                dom: 'lBfrtip',
                buttons: [
                    'copy',
                    'excel', 'pdf',
                    'colvis'
                ]

            }
        );


        async function updateChart(combineChart, data) {
            combineChart.data.labels = data.data.map(e => e.time)
            combineChart.data.datasets[0].data = data.data.map(e => e.price)
            combineChart.data.datasets[1].data = data.data.map(e => {
                let t = 0;
                [e.bu_val, e.sd_val, e.unknown_val].forEach(ee => {
                    if (ee) t += ee;
                })
                return t;
            })
            combineChart.data.datasets[2].data = data.data.map(e => e.bu_val)
            combineChart.data.datasets[3].data = data.data.map(e => e.sd_val)
            combineChart.data.datasets[4].data = data.data.map(e => e.bid_val)
            combineChart.data.datasets[5].data = data.data.map(e => e.ask_val)
            combineChart.update();
        }

        var sectorCodeList;
        $.ajax({
            url: `/api/getsectorcodelist`,
            method: 'GET',
            success: function (response) {
                sectorCodeList = response;
            },
            error: function (error) {
                console.error('Error fetching updated data:', error);
            }
        });


        let timeout = 0;
        let lastMd5 = ''
        let lastAJAX = 0
        function updateDataTable() {
            if (Date.now() - lastAJAX <= timeout) {
                return;
            }
            $.ajax({
                url: `/api/getsymbolsaccum`,
                method: 'GET',
                success: function (response) {

                    if (response.length == 0) {
                        return;
                    }
                    let mapSymbol = {}
                    response.forEach(e => {
                        mapSymbol[e.symbol] = e
                    })
                    let dataAll = [];
                    let statsAll = []
                    // console.table(response)
                    if (sectorCodeList) {
                        let sectorStat = {}
                        let accumField = ["pct", "unknown_vol", "unknown_val", "bu_vol", "bu_val", "sd_vol", "sd_val", "bid_vol", "bid_val", "ask_vol", "ask_val", "busd_vol", "busd_val"]
                        let marketStat = { tran: 0, tang: 0, thamchieu: 0, giam: 0, san: 0, UP: {}, DOWN: {}, REF: {}, CEILING: {}, FLOOR: {} }
                        accumField.forEach(f => {
                            marketStat.UP[f] = 0
                            marketStat.DOWN[f] = 0
                            marketStat.REF[f] = 0
                            marketStat.CEILING[f] = 0
                            marketStat.FLOOR[f] = 0
                        })
                        sectorCodeList.map(e => {
                            let stat = { tran: 0, tang: 0, thamchieu: 0, giam: 0, san: 0 }
                            let statSymbol = { tran: {}, tang: {}, thamchieu: {}, giam: {}, san: {} }
                            let accum = { UP: {}, DOWN: {}, REF: {}, CEILING: {}, FLOOR: {} }
                            accumField.forEach(f => {
                                accum.UP[f] = 0
                                accum.DOWN[f] = 0
                                accum.REF[f] = 0
                                accum.CEILING[f] = 0
                                accum.FLOOR[f] = 0
                            })
                            var lastTime = '';
                            var lastT = 0
                            e.codeList.forEach(
                                s => {
                                    let symbolData = mapSymbol[s];
                                    if (symbolData) {
                                        if (+symbolData.T > lastT) {
                                            lastT = +symbolData.T
                                            lastTime = symbolData.time
                                        }
                                        if (symbolData.pct == 0) {
                                            stat.thamchieu += 1
                                            accumField.forEach(f => {
                                                marketStat.REF[f] += vf(symbolData[f])
                                                accum.REF[f] += vf(symbolData[f])
                                            })

                                            statSymbol.thamchieu[s] = symbolData
                                        }
                                        if (symbolData.pct > 0) {
                                            if (symbolData.ceiling == symbolData.price) {
                                                stat.tran += 1
                                                marketStat.tran += 1
                                                statSymbol.tran[s] = symbolData
                                                accumField.forEach(f => {
                                                    marketStat.CEILING[f] += vf(symbolData[f])
                                                    accum.CEILING[f] += vf(symbolData[f])
                                                })
                                            }
                                            else {
                                                stat.tang += 1
                                                marketStat.tang += 1
                                                statSymbol.tang[s] = symbolData
                                                accumField.forEach(f => {
                                                    marketStat.UP[f] += vf(symbolData[f])
                                                    accum.UP[f] += vf(symbolData[f])
                                                })
                                            }



                                        }
                                        if (symbolData.pct < 0) {

                                            if (symbolData.floor == symbolData.price) {
                                                stat.san += 1
                                                marketStat.san += 1
                                                statSymbol.san[s] = symbolData
                                                accumField.forEach(f => {
                                                    marketStat.FLOOR[f] += vf(symbolData[f])
                                                    accum.FLOOR[f] += vf(symbolData[f])
                                                })
                                            }
                                            else {
                                                stat.giam += 1
                                                marketStat.giam += 1
                                                statSymbol.giam[s] = symbolData
                                                accumField.forEach(f => {
                                                    marketStat.DOWN[f] += vf(symbolData[f])
                                                    accum.DOWN[f] += vf(symbolData[f])
                                                })
                                            }


                                        }
                                    }

                                }
                            )

                            let t = Object.values(stat).reduce((a, b) => { return a + b }, 0)
                            if (t > 0) {
                                Object.keys(stat).forEach(k => {
                                    if (percent)
                                        stat[k] = stat[k] / t * 100
                                })
                            }
                            // console.log(e.vietnameseName)
                            // console.table(stat)
                            sectorStat[e.vietnameseName] = { stat: stat, accum: accum, statSymbol: statSymbol, time: lastTime, T: lastT }

                        })

                        let labels = Object.keys(sectorStat);
                        let tran = Object.values(sectorStat).map(e => e.stat.tran)
                        let tang = Object.values(sectorStat).map(e => e.stat.tang)
                        let thamchieu = Object.values(sectorStat).map(e => e.stat.thamchieu)
                        let giam = Object.values(sectorStat).map(e => e.stat.giam)
                        let san = Object.values(sectorStat).map(e => e.stat.san)

                        let F = ["CEILING", "UP", "REF", "DOWN", "FLOOR"]
                        let sum = {}
                        F.forEach(f => {
                            sum[f] = Object.values(sectorStat).map(e => e.accum[f].bu_val + e.accum[f].sd_val + e.accum[f].unknown_val)
                        })

                        combineChart.data.labels = labels
                        combineChart.data.datasets[0].data = tran
                        combineChart.data.datasets[1].data = tang
                        combineChart.data.datasets[2].data = thamchieu
                        combineChart.data.datasets[3].data = giam
                        combineChart.data.datasets[4].data = san
                        combineChart.update();


                        combineChartVal.data.labels = labels
                        combineChartVal.data.datasets[0].data = sum.CEILING
                        combineChartVal.data.datasets[1].data = sum.UP
                        combineChartVal.data.datasets[2].data = sum.REF
                        combineChartVal.data.datasets[3].data = sum.DOWN
                        combineChartVal.data.datasets[4].data = san.FLOOR
                        combineChartVal.update();
                        var sectorTable = {}
                        Object.keys(sectorStat).forEach(sector => {
                            var sd = sectorStat[sector]
                            sectorTable[sector] = { sector: sector, time: sd.time, T: sd.T, ...sd.statSymbol }
                        })

                        // console.table(sectorTable)

                        var table = $('#myTable').DataTable();
                        table.clear();
                        table.rows.add(Object.values(sectorTable)).draw()
                        // $('.tooltip').tooltipster();
                        // $('#mytable').DataTable();

                        // // Initialize Tooltipster for all elements with the 'tooltip' class
                        $('.tooltip').tooltipster({
                            // functionBefore: function (instance,helper) {
                            //     // Retrieve the tooltip content from the data-tooltip attribute
                            //     // callback($(this).data('tooltip'));
                            //     // console.table(instance)
                            //     console.log( $(helper.origin))
                            // }
                            functionInit: function (instance, helper) {
                                var content = $(helper.origin).data('tooltip')
                                // console.log(content.symbol)
                                // data=JSON.parse(content)
                                instance.content(() => {
                                    return generateDynamicContent(content)
                                });
                            },
                            timer: 15000
                        });

                        // // Initialize Tooltipster for all elements with the 'tooltip' class

                        // function generateDynamicContent() {
                        //     // You can generate dynamic content based on your logic
                        //     return '<p>This is dynamic HTML content.</p>' +
                        //         '<ul>' +
                        //         '<li>Item 1</li>' +
                        //         '<li>Item 2</li>' +
                        //         '<li>Item 3</li>' +
                        //         '</ul>';
                        // }

                        function generateDynamicContent(data) {
                            // You can generate dynamic content based on your logic
                            return '<div><p>Thông tin mã.</p>' +
                                '<ul>' +
                                '<li>Tên mã ' + data.symbol + '</li>' +
                                '<li>Tỉ lệ ' + data.pct + '</li>' +
                                '<li>Mua chủ động ' + vf(data.bu_val) + '</li>' +
                                '<li>Bán chủ động ' + vf(data.sd_val) + '</li>' +
                                '<li>KXĐ ' + vf(data.unknown_val) + '</li>' +
                                '<li>Mua chủ động ' + vf(data.bu_val) + '</li>' +
                                '</ul>' +
                                '<img src="logo.5ecddcbe.svg" alt="Your Image"> </div>';
                                ;
                        }

                        // $('.tooltip').tooltipster({
                        //     functionInit: function (instance, helper) {

                        //         var $origin = $(helper.origin),
                        //             dataOptions = $origin.attr('data-tooltipster');
                        //             console.log(dataOptions)
                        //             data = JSON.parse(dataOptions)
                        //         instance.content(()=>{
                        //             return generateDynamicContent(data)
                        //         });
                        //         // console.log('DataOption',dataOptions)
                        //         // if (dataOptions) {

                        //         //     dataOptions = JSON.parse(dataOptions);
                        //         //     $.each(dataOptions, function (name, option) {

                        //         //         instance.option(name, option);
                        //         //     });
                        //         // }
                        //     },
                        //     timer: 15000
                        // });

                    }





                    lastAJAX = Date.now()
                    // if (lastMd5 == response.md5) {
                    //     timeout += 1000
                    //     if (timeout >= 10000) {
                    //         timeout = 10000;
                    //         console.log('Timeout ', timeout, 'md5', response.md5)
                    //     }
                    // } else {
                    //     timeout = 0;
                    // }
                    // // console.table(response)
                    // lastMd5 = response.md5
                },
                error: function (error) {
                    console.error('Error fetching updated data:', error);
                }
            });
        }
        // updateDataTable()
        // Update DataTable every 5 seconds (adjust as needed)
        setInterval(updateDataTable, 1000);

        $(document).ready(function () {
            // Event listener for mouseover on cells     

            $('#mytable').DataTable();

            // Initialize Tooltipster for all elements with the 'tooltip' class
            console.log('Active tooltipse1')

            $('.tooltip').tooltipster();
            // $('.tooltip').tooltipster({
            //     content: function (callback) {
            //         // Retrieve the tooltip content from the data-tooltip attribute
            //         console.log('Active tooltipse')
            //         callback($(this).data('tooltip'));
            //     }
            // });
        });


    </script>
</body>

</html>